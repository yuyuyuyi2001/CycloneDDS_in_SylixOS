#define CU_TheoryDataPointsSize_ddsc_xtypes_assignability_basic(datapoints) ( datapoints.descr.n )
#define CU_TheoryDataPointsSlice_ddsc_xtypes_assignability_basic(datapoints, index) ( datapoints.descr.p[index], datapoints.desc1.p[index], datapoints.desc2.p[index], datapoints.fn_init1.p[index], datapoints.fn_init2.p[index], datapoints.fn_check1.p[index], datapoints.fn_check2.p[index] )
#define CU_TheoryDataPointsTypedef_ddsc_xtypes_assignability_basic() { struct { size_t n; const char * *p; } descr; struct { size_t n; const dds_topic_descriptor_t * *p; } desc1; struct { size_t n; const dds_topic_descriptor_t * *p; } desc2; struct { size_t n; sample_init *p; } fn_init1; struct { size_t n; sample_init *p; } fn_init2; struct { size_t n; sample_check *p; } fn_check1; struct { size_t n; sample_check *p; } fn_check2; }
#define CU_TheoryDataPointsSize_ddsc_xtypes_assignability_must_understand(datapoints) ( datapoints.rd_desc.n )
#define CU_TheoryDataPointsSlice_ddsc_xtypes_assignability_must_understand(datapoints, index) ( datapoints.rd_desc.p[index], datapoints.wr_desc.p[index], datapoints.assignable.p[index], datapoints.fn_init.p[index], datapoints.read_sample.p[index] )
#define CU_TheoryDataPointsTypedef_ddsc_xtypes_assignability_must_understand() { struct { size_t n; const dds_topic_descriptor_t * *p; } rd_desc; struct { size_t n; const dds_topic_descriptor_t * *p; } wr_desc; struct { size_t n; bool *p; } assignable; struct { size_t n; sample_init *p; } fn_init; struct { size_t n; bool *p; } read_sample; }
#define CU_TheoryDataPointsSize_ddsc_xtypes_assignability_type_consistency_enforcement(datapoints) ( datapoints.test.n )
#define CU_TheoryDataPointsSlice_ddsc_xtypes_assignability_type_consistency_enforcement(datapoints, index) ( datapoints.test.p[index], datapoints.rd_desc.p[index], datapoints.wr_desc.p[index], datapoints.kind.p[index], datapoints.prevent_type_widening.p[index], datapoints.ignore_seq_bounds.p[index], datapoints.ignore_str_bounds.p[index], datapoints.ignore_member_names.p[index], datapoints.force_type_validation.p[index], datapoints.assignable.p[index] )
#define CU_TheoryDataPointsTypedef_ddsc_xtypes_assignability_type_consistency_enforcement() { struct { size_t n; const char * *p; } test; struct { size_t n; const dds_topic_descriptor_t * *p; } rd_desc; struct { size_t n; const dds_topic_descriptor_t * *p; } wr_desc; struct { size_t n; dds_type_consistency_kind_t *p; } kind; struct { size_t n; bool *p; } prevent_type_widening; struct { size_t n; bool *p; } ignore_seq_bounds; struct { size_t n; bool *p; } ignore_str_bounds; struct { size_t n; bool *p; } ignore_member_names; struct { size_t n; bool *p; } force_type_validation; struct { size_t n; bool *p; } assignable; }
#define CU_TheoryDataPointsSize_ddsc_xtypes_assignability_enum_extensibility(datapoints) ( datapoints.rd_desc.n )
#define CU_TheoryDataPointsSlice_ddsc_xtypes_assignability_enum_extensibility(datapoints, index) ( datapoints.rd_desc.p[index], datapoints.wr_desc.p[index], datapoints.assignable.p[index], datapoints.fn_init.p[index], datapoints.read_sample.p[index] )
#define CU_TheoryDataPointsTypedef_ddsc_xtypes_assignability_enum_extensibility() { struct { size_t n; const dds_topic_descriptor_t * *p; } rd_desc; struct { size_t n; const dds_topic_descriptor_t * *p; } wr_desc; struct { size_t n; bool *p; } assignable; struct { size_t n; sample_init *p; } fn_init; struct { size_t n; bool *p; } read_sample; }
